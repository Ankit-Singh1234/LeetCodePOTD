# Zero-Filled Subarrays

## 📌 Problem Statement
You are given an integer array `nums`.  
A **zero-filled subarray** is a subarray consisting only of zeros.  
The task is to return the **total number of zero-filled subarrays**.

---

## 💡 Key Insight
If we have a sequence of `k` consecutive zeros, the total number of zero-filled subarrays inside it is:

\[
\frac{k \cdot (k+1)}{2}
\]

### Example
For `k = 3` (`[0, 0, 0]`):
- Length 1 subarrays → 3 (`[0], [0], [0]`)
- Length 2 subarrays → 2 (`[0,0], [0,0]`)
- Length 3 subarrays → 1 (`[0,0,0]`)
- ✅ Total = 3 + 2 + 1 = 6  

Formula check: \(\frac{3 \cdot 4}{2} = 6\)

For `k = 4` (`[0, 0, 0, 0]`):
- Subarrays = 4 + 3 + 2 + 1 = 10  
- ✅ Formula: \(\frac{4 \cdot 5}{2} = 10\)

---

## 🚀 Approach
1. Traverse the array.
2. Maintain a counter `count` for consecutive zeros.
3. For each zero:
   - Increase `count` by 1 (extend the streak).
   - Add `count` to result (all subarrays ending here).
4. If a non-zero is found, reset `count` to 0.

⏱️ Complexity: **O(n)**  
📦 Space: **O(1)**

---

## 💻 C++ Solution
```cpp
class Solution {
public:
    long long zeroFilledSubarray(vector<int>& nums) {
        long long count = 0, result = 0;

        for (int num : nums) {
            if (num == 0) {
                count++;        // extend current zero streak
                result += count; // add all subarrays ending here
            } else {
                count = 0;      // reset streak
            }
        }
        return result;
    }
};


Zero-Filled Subarrays
Problem Statement

We are given an integer array nums. A zero-filled subarray is a subarray consisting only of zeros.
The task is to return the total number of zero-filled subarrays.

Key Insight

If we have a sequence of k consecutive zeros, the total number of zero-filled subarrays inside it is:

𝑘
⋅
(
𝑘
+
1
)
2
2
k⋅(k+1)
	​

Why?

For k = 3 ([0, 0, 0]):

Length 1 subarrays = 3 → [0], [0], [0]

Length 2 subarrays = 2 → [0,0], [0,0]

Length 3 subarray = 1 → [0,0,0]

Total = 3 + 2 + 1 = 6
Formula check: 
3
⋅
4
2
=
6
2
3⋅4
	​

=6 ✅

For k = 4 ([0, 0, 0, 0]):
Subarrays = 4 + 3 + 2 + 1 = 10
Formula check: 
4
⋅
5
2
=
10
2
4⋅5
	​

=10 ✅

So the formula works because it counts all possible subarray lengths inside the streak of zeros.

Approach

Traverse the array.

Maintain a counter count for consecutive zeros.

For each zero:

Increase count by 1 (extend the streak).

Add count to result (all subarrays ending here).

If a non-zero is found, reset count to 0.

This runs in O(n) time and O(1) extra space.

C++ Solution
class Solution {
public:
    long long zeroFilledSubarray(vector<int>& nums) {
        long long count = 0, result = 0;

        for (int num : nums) {
            if (num == 0) {
                count++;        // extend current zero streak
                result += count; // add all subarrays ending here
            } else {
                count = 0;      // reset streak
            }
        }
        return result;
    }
};

Example Walkthrough

Input: nums = [0, 0, 1, 0]

First 0: count = 1 → result = 1

Second 0: count = 2 → result = 3

Encounter 1: reset count = 0

Last 0: count = 1 → result = 4

✅ Answer = 4
