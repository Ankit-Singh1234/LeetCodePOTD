# Zero-Filled Subarrays

## ğŸ“Œ Problem Statement
You are given an integer array `nums`.  
A **zero-filled subarray** is a subarray consisting only of zeros.  
The task is to return the **total number of zero-filled subarrays**.

---

## ğŸ’¡ Key Insight
If we have a sequence of `k` consecutive zeros, the total number of zero-filled subarrays inside it is:

\[
\frac{k \cdot (k+1)}{2}
\]

### Example
For `k = 3` (`[0, 0, 0]`):
- Length 1 subarrays â†’ 3 (`[0], [0], [0]`)
- Length 2 subarrays â†’ 2 (`[0,0], [0,0]`)
- Length 3 subarrays â†’ 1 (`[0,0,0]`)
- âœ… Total = 3 + 2 + 1 = 6  

Formula check: \(\frac{3 \cdot 4}{2} = 6\)

For `k = 4` (`[0, 0, 0, 0]`):
- Subarrays = 4 + 3 + 2 + 1 = 10  
- âœ… Formula: \(\frac{4 \cdot 5}{2} = 10\)

---

## ğŸš€ Approach
1. Traverse the array.
2. Maintain a counter `count` for consecutive zeros.
3. For each zero:
   - Increase `count` by 1 (extend the streak).
   - Add `count` to result (all subarrays ending here).
4. If a non-zero is found, reset `count` to 0.

â±ï¸ Complexity: **O(n)**  
ğŸ“¦ Space: **O(1)**

---

## ğŸ’» C++ Solution
```cpp
class Solution {
public:
    long long zeroFilledSubarray(vector<int>& nums) {
        long long count = 0, result = 0;

        for (int num : nums) {
            if (num == 0) {
                count++;        // extend current zero streak
                result += count; // add all subarrays ending here
            } else {
                count = 0;      // reset streak
            }
        }
        return result;
    }
};


Zero-Filled Subarrays
Problem Statement

We are given an integer array nums. A zero-filled subarray is a subarray consisting only of zeros.
The task is to return the total number of zero-filled subarrays.

Key Insight

If we have a sequence of k consecutive zeros, the total number of zero-filled subarrays inside it is:

ğ‘˜
â‹…
(
ğ‘˜
+
1
)
2
2
kâ‹…(k+1)
	â€‹

Why?

For k = 3 ([0, 0, 0]):

Length 1 subarrays = 3 â†’ [0], [0], [0]

Length 2 subarrays = 2 â†’ [0,0], [0,0]

Length 3 subarray = 1 â†’ [0,0,0]

Total = 3 + 2 + 1 = 6
Formula check: 
3
â‹…
4
2
=
6
2
3â‹…4
	â€‹

=6 âœ…

For k = 4 ([0, 0, 0, 0]):
Subarrays = 4 + 3 + 2 + 1 = 10
Formula check: 
4
â‹…
5
2
=
10
2
4â‹…5
	â€‹

=10 âœ…

So the formula works because it counts all possible subarray lengths inside the streak of zeros.

Approach

Traverse the array.

Maintain a counter count for consecutive zeros.

For each zero:

Increase count by 1 (extend the streak).

Add count to result (all subarrays ending here).

If a non-zero is found, reset count to 0.

This runs in O(n) time and O(1) extra space.

C++ Solution
class Solution {
public:
    long long zeroFilledSubarray(vector<int>& nums) {
        long long count = 0, result = 0;

        for (int num : nums) {
            if (num == 0) {
                count++;        // extend current zero streak
                result += count; // add all subarrays ending here
            } else {
                count = 0;      // reset streak
            }
        }
        return result;
    }
};

Example Walkthrough

Input: nums = [0, 0, 1, 0]

First 0: count = 1 â†’ result = 1

Second 0: count = 2 â†’ result = 3

Encounter 1: reset count = 0

Last 0: count = 1 â†’ result = 4

âœ… Answer = 4
